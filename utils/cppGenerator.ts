import { DeviceConfig, ButtonMapping, ActionConfig, KeypadConfig } from '../types';
import { RTC_GPIO_PINS } from '../constants';

export const generateCppCode = (device: DeviceConfig, buttons: ButtonMapping[], keypads: KeypadConfig[]): string => {
  const enabledKeypads = keypads.filter(k => k.enabled);

  // 1. Generate Definitions for HID Keys (collect from both buttons and enabled keypads)
  const buttonActions = buttons.flatMap(b => [b.shortPress, b.longPress]);
  const keypadActions = enabledKeypads.flatMap(k => k.keys.flatMap(key => [key.shortPress, key.longPress]));
  const allActions = [...buttonActions, ...keypadActions];

  const uniqueKeys = Array.from(new Set(allActions.filter(a => a.mode === 'key').map(a => a.keyConfig)));
  const defineLines = uniqueKeys
    .map(k => `#define ${k.name.padEnd(20)} ${k.code}`)
    .join('\n');

  // 2. Generate Pin Constants & Arrays
  const buttonPinConstants = buttons
    .map((b, index) => `const int pinBtn${index} = ${b.pin};`)
    .join('\n');

  // 3. Helper to generate modifier byte
  const getModByte = (m: any) => {
    let val = 0;
    if (m.ctrl) val |= 0x01;  // LEFT_CTRL
    if (m.shift) val |= 0x02; // LEFT_SHIFT
    if (m.alt) val |= 0x04;   // LEFT_ALT
    if (m.gui) val |= 0x08;   // LEFT_GUI
    return `0x${val.toString(16).toUpperCase().padStart(2, '0')}`;
  };

  // 4. Text Table Generation
  const uniqueTexts = Array.from(new Set(allActions.filter(a => a.mode === 'text').map(a => a.text)));
  const textToIndex = (text: string) => uniqueTexts.indexOf(text);
  const textTable = uniqueTexts.map(t => `"${t}"`).join(',\n  ');

  // 5. Generate Action Struct Helper
  const generateActionStruct = (action: ActionConfig, enabled: boolean = true) => {
    if (!enabled) return `{ 2, 0, 0, -1 }`; // Mode 2 = None

    const mode = action.mode === 'key' ? 0 : 1;
    const keyCode = action.mode === 'key' ? action.keyConfig.name : '0';
    const mods = action.mode === 'key' ? getModByte(action.modifiers) : '0';
    const txtIdx = action.mode === 'text' ? textToIndex(action.text) : -1;

    return `{ ${mode}, ${keyCode}, ${mods}, ${txtIdx} }`;
  };

  // 6. Generate Button Definitions (Direct GPIO)
  const buttonStructs = buttons.map((b, index) => {
    const shortAction = generateActionStruct(b.shortPress);
    const longAction = generateActionStruct(b.longPress, b.longPressEnabled);
    return `  { pinBtn${index}, ${shortAction}, ${longAction}, HIGH, 0, HIGH, 0, false }`;
  }).join(',\n');

  // 7. Generate Keypad Definitions
  const keypadDefs = enabledKeypads.map((kp, idx) => {
    // Generate Row and Col pin arrays
    const rowPins = `{ ${kp.rowPins.join(', ')} }`;
    const colPins = `{ ${kp.colPins.join(', ')} }`;

    // Generate 16 Button structs for this keypad (flattened row-major)
    const keyStructs = kp.keys.map(k => {
      const shortAction = generateActionStruct(k.shortPress);
      const longAction = generateActionStruct(k.longPress, k.longPressEnabled);
      // Pin is -1 for virtual keypad buttons, we manage reading manually
      return `    { -1, ${shortAction}, ${longAction}, HIGH, 0, HIGH, 0, false }`;
    }).join(',\n');

    return `
// Keypad ${idx + 1}: ${kp.name}
const int kp${idx}_rows[4] = ${rowPins};
const int kp${idx}_cols[4] = ${colPins};

Button kp${idx}_keys[16] = {
${keyStructs}
};
    `;
  }).join('\n');

  // 8. Wakeup Pin Calculation
  const rtcButtons = buttons.filter(b => RTC_GPIO_PINS.includes(b.pin));
  // Note: Matrix keypad wakeup is complex, we only support single button wakeup for now
  const wakePin = rtcButtons.length > 0 ? rtcButtons[0].pin : -1;

  return `/**
 * Generated by ESP32 BLE Keygen
 * Device: ${device.name}
 * Manufacturer: ${device.manufacturer}
 * 
 * REQUIRED LIBRARY: NimBLE-Arduino by h2zero
 */

#include <NimBLEDevice.h>
#include <NimBLEHIDDevice.h>
#include <NimBLEAdvertising.h>
#include <WiFi.h>
#include "esp_sleep.h"

// --- Configuration ---
${buttonPinConstants}

const unsigned long debounceTime = ${device.debounceTime}; // ms
const unsigned long longPressTime = ${device.longPressDuration}; // ms
const unsigned long idleTimeout = ${device.sleepTimeout}; // ms before deep sleep

// --- HID Keycodes used in this mapping ---
${defineLines}

// --- ASCII to HID Map (Standard US Layout) ---
const uint8_t ASCII_MAP[95][2] = {
  {0, 0x2C}, {1, 0x1E}, {1, 0x34}, {1, 0x20}, {1, 0x21}, {1, 0x22}, {1, 0x24}, {0, 0x34}, // 32-39
  {1, 0x26}, {1, 0x27}, {1, 0x25}, {1, 0x2E}, {0, 0x36}, {0, 0x2D}, {0, 0x37}, {0, 0x38}, // 40-47
  {0, 0x27}, {0, 0x1E}, {0, 0x1F}, {0, 0x20}, {0, 0x21}, {0, 0x22}, {0, 0x23}, {0, 0x24}, // 48-55
  {0, 0x25}, {0, 0x26}, {1, 0x33}, {0, 0x33}, {1, 0x36}, {0, 0x2E}, {1, 0x37}, {1, 0x38}, // 56-63
  {1, 0x1F}, {1, 0x04}, {1, 0x05}, {1, 0x06}, {1, 0x07}, {1, 0x08}, {1, 0x09}, {1, 0x0A}, // 64-71
  {1, 0x0B}, {1, 0x0C}, {1, 0x0D}, {1, 0x0E}, {1, 0x0F}, {1, 0x10}, {1, 0x11}, {1, 0x12}, // 72-79
  {1, 0x13}, {1, 0x14}, {1, 0x15}, {1, 0x16}, {1, 0x17}, {1, 0x18}, {1, 0x19}, {1, 0x1A}, // 80-87
  {1, 0x1B}, {1, 0x1C}, {1, 0x1D}, {0, 0x2F}, {0, 0x31}, {0, 0x30}, {1, 0x23}, {1, 0x2D}, // 88-95
  {0, 0x35}, {0, 0x04}, {0, 0x05}, {0, 0x06}, {0, 0x07}, {0, 0x08}, {0, 0x09}, {0, 0x0A}, // 96-103
  {0, 0x0B}, {0, 0x0C}, {0, 0x0D}, {0, 0x0E}, {0, 0x0F}, {0, 0x10}, {0, 0x11}, {0, 0x12}, // 104-111
  {0, 0x13}, {0, 0x14}, {0, 0x15}, {0, 0x16}, {0, 0x17}, {0, 0x18}, {0, 0x19}, {0, 0x1A}, // 112-119
  {0, 0x1B}, {0, 0x1C}, {0, 0x1D}, {1, 0x2F}, {1, 0x31}, {1, 0x30}, {1, 0x35}              // 120-126
};

// --- Structs ---

struct ActionConfig {
  uint8_t mode;      // 0=Key, 1=Text, 2=None
  uint8_t keyCode;
  uint8_t modifiers;
  int textIndex;
};

struct Button {
  int pin; // -1 if virtual/keypad
  ActionConfig shortPress;
  ActionConfig longPress;
  
  // State Machine
  bool lastReading;             // Immediate reading from previous loop
  unsigned long lastDebounceTime; // Last time pin changed
  bool state;                   // Stable debounced state
  unsigned long pressTime;      // Time when state went LOW
  bool longPressHandled;        // Flag if long press was already executed
  
  // Method to update state based on reading (High/Low)
  bool updateAndCheck(bool reading, unsigned long now);
};

// Text Macros
const char* textTable[] = {
  ${textTable || '""'}
};

// Direct GPIO Buttons
Button buttons[] = {
${buttonStructs}
};
const int buttonCount = sizeof(buttons) / sizeof(buttons[0]);

${keypadDefs}

unsigned long lastActivityTime = 0;

NimBLEHIDDevice* hid;
NimBLECharacteristic* input;

// --- Helper Functions ---

void sendReport(uint8_t modifiers, uint8_t code) {
  uint8_t report[8] = {0};
  report[0] = modifiers; // Modifier byte
  report[2] = code;      // Keycode byte
  input->setValue(report, sizeof(report));
  input->notify();
  delay(15);
  
  // Release
  memset(report, 0, sizeof(report));
  input->setValue(report, sizeof(report));
  input->notify();
}

void sendChar(char c) {
  if (c < 32 || c > 126) return; // Only support ASCII printable
  uint8_t index = c - 32;
  uint8_t mod = ASCII_MAP[index][0] ? 0x02 : 0x00; // 0x02 is Left Shift
  uint8_t key = ASCII_MAP[index][1];
  sendReport(mod, key);
  delay(15);
}

void typeText(const char* text) {
  int len = strlen(text);
  for (int i = 0; i < len; i++) {
    sendChar(text[i]);
  }
}

void executeAction(ActionConfig& action) {
  if (action.mode == 0) { // Key
    sendReport(action.modifiers, action.keyCode);
  } else if (action.mode == 1) { // Text
    if (action.textIndex >= 0) {
      typeText(textTable[action.textIndex]);
    }
  }
}

// Button State Machine Implementation
bool Button::updateAndCheck(bool reading, unsigned long now) {
  bool activityDetected = false;

  // 1. Debounce Logic
  if (reading != lastReading) {
    lastDebounceTime = now;
    lastReading = reading;
    activityDetected = true;
  }

  if ((now - lastDebounceTime) > debounceTime) {
    // 2. State Change Detection
    if (reading != state) {
      state = reading;

      if (state == LOW) {
        // Pressed
        pressTime = now;
        longPressHandled = false;
      } else {
        // Released
        if (!longPressHandled) {
           // Short Press Action
           executeAction(shortPress);
        }
      }
      activityDetected = true;
    }
    
    // 3. Long Press Detection while held
    if (state == LOW) {
      if (!longPressHandled && (now - pressTime > longPressTime)) {
         if (longPress.mode != 2) { // 2 = None
           executeAction(longPress);
           longPressHandled = true;
         }
      }
    }
  }
  return activityDetected;
}

// --- Server Callbacks ---
class ServerCallbacks: public NimBLEServerCallbacks {
  void onConnect(NimBLEServer* pServer, ble_gap_conn_desc* desc) {
    Serial.print("Client connected: ");
    Serial.println(NimBLEAddress(desc->peer_ota_addr).toString().c_str());
    pServer->updateConnParams(desc->conn_handle, 6, 20, 0, 100);
  };

  void onDisconnect(NimBLEServer* pServer) {
    Serial.println("Client disconnected - restarting advertising");
    NimBLEDevice::getAdvertising()->start();
  };
};

void setup() {
  Serial.begin(115200);

  WiFi.mode(WIFI_MODE_NULL);
  WiFi.disconnect(true);

  // Initialize GPIO Buttons
  for (int i = 0; i < buttonCount; i++) {
    pinMode(buttons[i].pin, INPUT_PULLUP);
    buttons[i].lastReading = HIGH;
    buttons[i].state = HIGH;
    buttons[i].longPressHandled = false;
  }

  // Initialize Keypads
  ${enabledKeypads.map((kp, i) => `
  // Keypad ${i + 1} Pin Setup
  for(int i=0; i<4; i++) {
    pinMode(kp${i}_rows[i], OUTPUT);
    digitalWrite(kp${i}_rows[i], HIGH); // Idle High
    pinMode(kp${i}_cols[i], INPUT_PULLUP); // Inputs with Pullup
  }
  `).join('\n')}

  NimBLEDevice::setPower(ESP_PWR_LVL_P9);
  NimBLEDevice::setSecurityAuth(true, true, true); 

  NimBLEDevice::init("${device.name}");
  NimBLEServer* pServer = NimBLEDevice::createServer();
  pServer->setCallbacks(new ServerCallbacks());
  
  hid = new NimBLEHIDDevice(pServer);
  input = hid->getInputReport(1);

  hid->setManufacturer("${device.manufacturer}");
  hid->setPnp(0x02, 0x02E5, 0xABCD, 0x0100);
  hid->setHidInfo(0x00, 0x01);

  uint8_t reportMap[] = {
    0x05, 0x01, 0x09, 0x06, 0xA1, 0x01, 
    0x05, 0x07, 0x19, 0xE0, 0x29, 0xE7, 0x15, 0x00, 0x25, 0x01, 0x75, 0x01, 0x95, 0x08, 0x81, 0x02, 
    0x95, 0x01, 0x75, 0x08, 0x81, 0x01, 
    0x95, 0x06, 0x75, 0x08, 0x15, 0x00, 0x25, 0xE7, 0x05, 0x07, 0x19, 0x00, 0x29, 0xE7, 0x81, 0x00, 
    0xC0
  };
  
  hid->setReportMap(reportMap, sizeof(reportMap));
  hid->startServices();

  NimBLEAdvertising* pAdv = pServer->getAdvertising();
  pAdv->setAppearance(HID_KEYBOARD);
  pAdv->addServiceUUID(hid->getHidService()->getUUID());
  
  NimBLEAdvertisementData scanResponse;
  scanResponse.setName("${device.name}");
  pAdv->setScanResponseData(scanResponse);
  
  pAdv->start();

  Serial.println("BLE Keyboard Ready.");
  lastActivityTime = millis();
}

void loop() {
  unsigned long now = millis();
  bool activityDetected = false;

  // 1. Scan GPIO Buttons
  for (int i = 0; i < buttonCount; i++) {
    bool reading = digitalRead(buttons[i].pin);
    if (buttons[i].updateAndCheck(reading, now)) {
      activityDetected = true;
    }
  }

  // 2. Scan Keypads
  ${enabledKeypads.map((kp, kIdx) => `
  // Scan Keypad ${kIdx + 1}
  for (int r = 0; r < 4; r++) {
    digitalWrite(kp${kIdx}_rows[r], LOW); // Activate Row
    
    for (int c = 0; c < 4; c++) {
      bool reading = digitalRead(kp${kIdx}_cols[c]);
      // Key at [r][c] corresponds to linear index r*4 + c
      int keyIdx = r * 4 + c;
      if (kp${kIdx}_keys[keyIdx].updateAndCheck(reading, now)) {
        activityDetected = true;
      }
    }
    
    digitalWrite(kp${kIdx}_rows[r], HIGH); // Deactivate Row
  }
  `).join('\n')}

  if (activityDetected) {
    lastActivityTime = now;
  }

  delay(10); // Faster loop for better polling

  ${device.deepSleepEnabled ? `
  if ((now - lastActivityTime) > idleTimeout) {
     Serial.println("Entering Deep Sleep...");
     Serial.flush();
     ${wakePin !== -1 ? `esp_sleep_enable_ext0_wakeup((gpio_num_t)${wakePin}, 0);` : '// No RTC pin mapped!'}
     esp_deep_sleep_start();
  }` : ''}
}`;
};
